[[Overview]]
== Overview

=== MapML in relation to other feature encodings
MapML is unique relative to other encodings but the concern that it is duplicative in some way. It is trying to apply geospatial information on the Web best practices, and adapting them to users where applicable.

The requirements for MapML were originally developed and published on the Web here: http://maps4html.github.io/HTML-Map-Element-UseCases-Requirements. MapML is an extension to HTML, which if implemented, implies that the browser understands map / layer semantics (however those elements are eventually named), as well as feature / property / geometry semantics. As such it is intended to be a user-oriented format. For example, today on the Web, users create Web pages in all manner of styles, but the common denominator is HTML and CSS and possibly JavaScript for progressive enhancement. Today, there is no map / layer behavior, much less feature / property / geometry semantics, in the browser (proof: try disabling JavaScript, then go to Google Maps). MapML provides the ability to encode map / layer and feature / property / geometry semantics in one (simple) format that will be read and interpreted by browsers directly. It is user-oriented, to the extent this is possible for maps. But it brings geographic knowledge to the browser, and it's the browser that is our user agent.

There is no other encoding or service that attempts to do this. If GeoJSON, or GML, or KML was suitable, browsers would have implemented or be able to implement those directly. MapML should not be constrained by those other encodings should the need for user-oriented features arise (e.g. markup in coordinate strings and possibly other requirements). A major objective of MapML is to make the browser understand not only where the user is (GeoLocation API, https://www.w3schools.com/html/html5_geolocation.asp), but also to understand where features are in relation to the user (MapML should achieve this).

Take, for example vector tiles. Vector tiles are an 'unknown media type' as far as the browser is concerned.  As such, they are handled by the JavaScript layer, which is to say, not by the browser, except for through the canvas API calls by the JavaScript.  Vector tiles are even less interoperable than png tiles, since the browser engine 'understands' how to layout and paint png and other image formats.  Their main advantage is bandwidth conservation, which is important, but it's not the first step in standardization of geospatial concepts in the browser.

MapML is not overlapping or duplicating vector tiles.  However, a MapML client engine, whether it was implemented in JavaScript, or WASM, or preferably by the browser, could use vector tiles to paint a map layer.  The main issue I see with that is the standardization of the tile format to the point where its as widely understood and implemented as png (say), but that may eventually happen.  Finally, despite the canvas element, vector tiles styling is done using scripting, because they are not DOM related in that sense, hence not susceptible to styling via CSS. i.e. not a standard yet.

Regarding the WFS 3 initiative: who is it for?  Web devs?  If so, just add a GeoJSON format to the output and it will work better, without changing the whole W*S model. If it's for users, we should consider what users, and possibly talk about including MapML as the default output format.  I think this could be done even without changing the whole W*S model, and we would leverage infrastructure in place.  MapML is trying to change the way we see the world, not how the world is. Browser developers call this “paving the cow paths”. WFS 3 is trying to change how the world is, which is fraught and unlikely to succeed.  See also Tim Berners-Lee on the Test of Independent Invention.

[NOTE]
.Instructions
====
This 4-overview.adoc file helps the reader to better understand the various sections of the ER. It should be written like an extended table of contents.
====

== Feature Encoding
=== Current version encoding
This section describes the goods and bads of the current encoding.

The current proposed encoding is a direct translation of the GeoJSON Encoding into XML.

=== Alternative feature encodings

Three alternatives are presented below. All three rely on the use of microdata to specify the non-geometrical properties of the feature. The way the encode geometry is different.
We have to better discuss about the actual CRS used for the features. For the moment I'm assuming extent coordinates.
Since MapML is intended for representing 2D maps, I'm only considering 2D coordinates.

=== Alternative 1: Compact geometry encoding with microdata
This encoding is departing form the general feature model where a feature can have geopmetrical and non-geometrical properties at the same level. Instead, it assumes that the content of a feature is characterized by its geometrical properties first and non-geometrical properties can be attached to it as subproperties. The advantage of this approach is that we can attach non-geometrical properties to the complete geometry but also to any part of it.

In this encoding root feature elements are named <polygon>, <polyline>... that. Inside this elements,  html text is included describing the feature. We are using microdata to include tag the html text with semantics. In addition, We are introducing the linearRing element that includes the coordinates of the polygon.

The style of the polygon applies to all linearRigns but can be overwritten by one of them. It does on apply to the non-geometrical properties that should define their one styles.

.Example of a polygon encoding
[source,html]
----
<mapml>
  <polygon id="myrestaurant" style="fill:red;stroke:black;stroke-width:3;opacity:0.5" itemscope itemtype="http://schema.org/Restaurant">
    <linearRing boundary="exterior">123,321 124,322 126,322 123,321</linearRing>
    <h1 itemprop="name">Fondue for Fun and Fantasy</h1>
    <p itemprop="description">Fantastic and fun for all your cheesy occasions.</p>
    <p>Open: <span itemprop="openingHours" content="Mo,Tu,We,Th,Fr,Sa,Su 11:30-23:00">Daily from 11:30am till 11pm</span></p>
    <p>Phone: <span itemprop="telephone" content="+155501003333">555-0100-3333</span></p>
    <p>View <a itemprop="menu" href="http://example.com/menu">our menu</a>.</p>
  </polygon>
</mapml>
----

The following example shows how se can add non-geometrical properties to an inner ring.

.Example of a polygon with a ring of a different color and additional non-geometrical properties.
[source,html]
----
<mapml>
  <polygon id="myrestaurant" style="fill:red;stroke:black;stroke-width:3;opacity:0.5" itemscope itemtype="http://schema.org/Restaurant">
    <h1 itemprop="name">Fondue for Fun and Fantasy</h1>
    <p itemprop="description">Fantastic and fun for all your cheesy occasions.</p>
    <p>Open: <span itemprop="openingHours" content="Mo,Tu,We,Th,Fr,Sa,Su 11:30-23:00">Daily from 11:30am till 11pm</span></p>
    <p>Phone: <span itemprop="telephone" content="+155501003333">555-0100-3333</span></p>
    <p>View <a itemprop="menu" href="http://example.com/menu">our menu</a>.</p>
    <linearRing boundary="exterior">123,321 124,322 126,322 123,321</linearRing>
    <linearRing boundary="interior" style="stroke:orange;stroke-width:5">123.5,321.5 124.5,322.5 125.5,321.5 123.5,321.5
      <p itemprop="description">Hole in the restaurant land.</p>
    </linearRing>
  </polygon>
</mapml>
----

=== Alternative 2: Compact geometry encoding with microdata

.Example of a polygon encoding
[source,html]
----
<mapml>
  <feature id="myrestaurant" itemscope itemtype="http://schema.org/Restaurant">
    <h1 itemprop="name">Fondue for Fun and Fantasy</h1>
    <p itemprop="description">Fantastic and fun for all your cheesy occasions.</p>
    <p>Open: <span itemprop="openingHours" content="Mo,Tu,We,Th,Fr,Sa,Su 11:30-23:00">Daily from 11:30am till 11pm</span></p>
    <p>Phone: <span itemprop="telephone" content="+155501003333">555-0100-3333</span></p>
    <p>View <a itemprop="menu" href="http://example.com/menu">our menu</a>.</p>
    <polygon id="MyRestaurantGeometry" style="fill:red;stroke:black;stroke-width:5;opacity:0.5" itemscope itemtype="http://pending.schema.org/GeospatialGeometry">
      <linearRing boundary="exterior">123,321 124,322 126,322 123,321</linearRing>
    </polygon>
  </feature>
</mapml>
----

=== Alternative 3: GML geometry encoding with microdata
The following encoding reuses GML geometrical classes to encode the geometrical properties. In this case, there is neither namespace nor GML schema but only the reuse of the GML encoding of geometrical features. We are also eliminating the need for defining feature types a priori.The resulting notation is not terrible in terms of size compared to the other more compact alternatives.

Since we have relaxed GML validation, we can consider that GML elements are extensible and we can add attributes and element when needed. One of our additions is the inclusion of style to represent how the objects need to be portrait in the screen. In the following examples we use the style property. We could also use the other approaches to associate styles to elements in HTML such as the use of "class" names or the association of styles to element id's.

[NOTE]
====
The use of SVG (css) styles in GML is not new and was introduced in GML 3.0.0 and still present in the informative annex H in GML 3.2.1. Nevertheless, the encoding suggested here is different and based on how HTML links elements with css styles.
====

.Example of a polygon encoding
[source,html]
----
<mapml>
  <feature id="myrestaurant" style="stroke:black;stroke-width:5;opacity:0.5" itemscope itemtype="http://schema.org/Restaurant">
    <h1 itemprop="name">Fondue for Fun and Fantasy</h1>
    <p itemprop="description">Fantastic and fun for all your cheesy occasions.</p>
    <p>Open: <span itemprop="openingHours" content="Mo,Tu,We,Th,Fr,Sa,Su 11:30-23:00">Daily from 11:30am till 11pm</span></p>
    <p>Phone: <span itemprop="telephone" content="+155501003333">555-0100-3333</span></p>
    <p>View <a itemprop="menu" href="http://example.com/menu">our menu</a>.</p>
    <Polygon id="MyRestaurantGeometry" style="fill:lime;stroke:black;stroke-width:5;opacity:0.5" itemscope itemtype="http://www.opengis.net/gml/3.2">
      <exterior>
        <LinearRing>
          <posList>123 321 124 322 126 322 123 321
          </posList>
        </LinearRing>
      </exterior>
    </Polygon>
  </feature>
</mapml>
----

In this example, we making use of the relaxation of GML validation to include new style attribute to in inner ring and to add non-geometrical properties to it.

.Example of a polygon encoding with holes
[source,html]
----
<mapml>
  <feature id="myrestaurant" style="stroke:black;stroke-width:5;opacity:0.5" itemscope itemtype="http://schema.org/Restaurant">
    <h1 itemprop="name">Fondue for Fun and Fantasy</h1>
    <p itemprop="description">Fantastic and fun for all your cheesy occasions.</p>
    <p>Open: <span itemprop="openingHours" content="Mo,Tu,We,Th,Fr,Sa,Su 11:30-23:00">Daily from 11:30am till 11pm</span></p>
    <p>Phone: <span itemprop="telephone" content="+155501003333">555-0100-3333</span></p>
    <p>View <a itemprop="menu" href="http://example.com/menu">our menu</a>.</p>
    <Polygon id="MyRestaurantGeometry" style="fill:lime;stroke:black;stroke-width:3;opacity:0.5" itemscope itemtype="http://www.opengis.net/gml/3.2">
      <exterior>
        <LinearRing>
          <posList>123 321 124 322 126 322 123 321
          </posList>
        </LinearRing>
      </exterior>
      <interior style="stroke:orange;stroke-width:5">
        <LinearRing>
          <posList>123.5 321.5 124.5 322.5 125.5 321.5 123.5 321.5
          </posList>
        </LinearRing>
        <span itemscope itemtype="http://schema.org/Thing">
          <p itemprop="description">Hole in the restaurant land.</p>
        </span>
      </interior>
    </Polygon>
  </feature>
</mapml>
----

If we opt for this approach, we should detail what extensions are allowed in the specification. In addition, we could need some addition to GML objects, such as the addition of ellipses.

== CCS Symbolization

CSS stands for Cascading Style Sheets. CSS describes how HTML elements are to be displayed on screen. A CSS is a sequence of rule-sets the consist of two parts

* The selector, that points to the HTML element to be symbolized
* The declaration block that contains one or more symbol declarations

.Example of a ruleset in CSS
[source,css]
----
p {
    color: red;
    text-align: center;
}
----

In the example the _selector_ points to all <p> elements and declares the letters will be _red_ and paragraph will be _centered_.

=== How to apply css styles to geometries
The more direct way to apply ccs symbolization is to do it inline

.Example of a polygon encoding
[source,html]
----
<polygon style="fill:red;stroke:black;stroke-width:5;opacity:0.5">
...
</polygon>
----

Another direct way to set styles is to use class (or id) to assign a css ruleset.

[source,html]
----
<style>
.nice
{
  fill:red;stroke:black;stroke-width:5;opacity:0.5
}
</style>

<polygon class="nice">
...
</polygon>
----

CSS has a way to select elements to be symbolized depending on the values of some attributes of the element.

[source,html]
----
<style>
polygon[type="road"]
{
  fill:red;stroke:black;stroke-width:5;opacity:0.5
}
</style>

<polygon type="road">
...
</polygon>
----

CSS has selectors that can be used to select element tag names, class attributes or elements id's. An interesting capability is that selectors can be used to select whatever element name that has an attribute (using the '*' character).

[source,html]
----
<style>
*[type="road"]{
    background:red;
}
</style>
<feature>
  <properties>
    <span type="road">road</span>
  </properties>
</feature>
----

As suggested by https://www.brmwebdev.com/dev/css/schema-based-styling, we can use this to select elements of a particular itemtype. Going further in this approach, we can select itemtype's that are in a particular scope. I have not been ale to find anyone suggesting that, but it is what you should do if you want to be precise in your selectors. This approach was already mentioned in OGC 16-053r1.

[source,html]
----
<style>
*[itemtype="http://www.opengis.net/road"] [itemprop="type"]{
    background:red;
}
</style>
<feature>
  <properties>
    <div itemscope itemtype="http://www.opengis.net/road">
      <span itemprop="type">road</span>
    </div>
  </properties>
</feature>
----

Exploring the combinations of all this possible combinations together, and analyzing what is possible in CSS, we can found some important limitations in CSS that prevents us from doing things that are common in GIS such us conditioning the style of a geometry to some values of the properties or specify a style declaration value as function of a property value.

=== Limitations in CSS
In the experimentation done to apply CCS to features with properties and geometry, we have detected the following limitations:name: value

* You cannot set select an element of the HTML and apply the symbol to another element
* You cannot set a selector based on the value of the element (you can do it based on an attribute of the element)
* You cannot set a selector based on the value of two properties at the same level.
* You cannot set a symbol declaration value (e.g. _width_ ) as a function of a value of an element or attribute in the HTML

It seems that the limitations in the selectors syntax where imposed to allow a faster parser of the HTML-CSS styler.

==== You cannot set a selector based on the value of the element.
CSS selectors can only select elements based attributes but not on element values (a.k.a element innerHTML). The use of the attribute "content" of microdata could be a fix to this limitation even if we are forced to repeat the value.

[source,html]
----
<style>
*[itemtype="http://www.opengis.net/road"] [itemprop="theme"][content="road"]{
    background:red;
}
</style>
<feature>
  <properties>
      <table a="b" class="table-properties" itemscope itemtype="http://www.opengis.net/road">
        <tbody>
          <tr>
            <th scope="row">id</th>
            <td itemprop="id">10964418e33d457aabd6f6ab10dc2e4a</td>
          </tr>
          <tr>
            <th scope="row">theme</th>
            <td itemprop="theme" content="road">road</td>
          </tr>
        </tbody>
      </table>
  </properties>
  <geometry>
     <polygon>
     </polygon>
  </geometry>
</feature>
----

To avoid the need to repeat the content as an _attribute_ and as a _value_, you could use CSS content property as suggested here: https://www.w3schools.com/cssref/pr_gen_content.asp. In the following example, we populate the innerHTML span element with the content of the  _content_ attribute using the CSS declaration _content_.

[source,html]
----
<html>
<style>
feature *[itemtype="http://www.opengis.net/road"] [itemprop="theme"][content="highway"] {
    background:red;
}

feature *[itemtype="http://www.opengis.net/road"] [itemprop="theme"]::after {
    content: attr(content);
}
</style>

<feature>
  <properties>
    <div itemscope itemtype="http://www.opengis.net/road">
      <span itemprop="theme" content="highway"></span>
  </properties>
</feature>
----
==== You cannot set select an element of the HTML and apply the symbol to another element
In principle, CSS was not designed to select some elements but apply the style to another element. In our case, this means that in general it is not possible to define a selector depending on "properties" and apply this to "geometry".
The only approximation to this behavior is to select the polygon that is a child of geometry that has a _precedent sibling_ (using ~) with an attribute value. It is still possible to go into single attribute values (that is what we need).

[source,html]
----
<style>
properties[type="road"] ~ geometry polygon {
    background:red;
}
</style>

<feature>
  <properties type="road">
      <table>
      </table>
  </properties>
  <geometry>
     <polygon>
	polygon
     </polygon>
  </geometry>
</feature>
----

The use of JavaScript can help to overcome this limitation. We can use querySelectorAll to make use of selector of properties and className to apply the style to geometries.

[source,html]
----
<style>
.road_red {
    background:red;
}
</style>
<script>
function setColorsToGeometries()
{
	var roads=document.querySelectorAll('*[itemtype="http://www.opengis.net/road"] [itemprop="theme"][content="road"]');

	for (var i=0; i<roads.length; i++)
	{
		var elem=roads[i];
		while (elem && elem.tagName.toLowerCase()!="properties")
			elem=elem.parentElement;
		elem.parentElement.getElementsByTagName("geometry")[0].className="road_red";
	}
}
</script>

<body onLoad="setColorsToGeometries()">
  <feature>
    <properties>
        <table a="b" class="table-properties" itemscope itemtype="http://www.opengis.net/road">
          <tbody>
            <tr>
              <th scope="row">theme</th>
              <td itemprop="theme" content="road">road</td>
            </tr>
          </tbody>
        </table>
    </properties>
    <geometry>
       <polygon>
       </polygon>
    </geometry>
  </feature>
</body>
----

=== Extensions of CSS to support geospatial requirements
NOTE: We need to study the use of CSS styling as defined in geoserver: http://docs.geoserver.org/latest/en/user/styling/css/index.html#css and https://carto.com/docs/carto-engine/cartocss/

One of the needed extensions the capability to apply a selector based on some _properties_ values to the _geometry_. Our proposal is to incorporate _condition1_ attribute to point another selector that will add extra conditions based on elements that are not directly the ones to simbolize. Both the _selector_ and the _condition1_ should be of the same father.

A suggested possibility is:

[source,html]
----
<style>
feature polygon; condition1: feature *[itemtype="http://www.opengis.net/road"] [itemprop="theme"][content="road"]
{
    background:red;
}
</style>
<feature>
  <properties>
      <table a="b" class="table-properties" itemscope itemtype="http://www.opengis.net/road">
        <tbody>
          <tr>
            <th scope="row">id</th>
            <td itemprop="id">10964418e33d457aabd6f6ab10dc2e4a</td>
          </tr>
          <tr>
            <th scope="row">theme</th>
            <td itemprop="theme" content="road">road</td>
          </tr>
        </tbody>
      </table>
  </properties>
  <geometry>
     <polygon>
     </polygon>
  </geometry>
</feature>
----

Another extension iscould be to condition a declaration value (e.g. width) to a property value (e.g. lanes). This could be achieved by using a selector as a value of a symbol declaration:

[source,html]
----
<style>
feature polygon; condition1: feature *[itemtype="http://www.opengis.net/road"] [itemprop="theme"][content="road"]
{
    background:red;
    label: feature *[itemtype="http://www.opengis.net/road"] [itemprop="name"][content];
    stroke-width: feature *[itemtype="http://www.opengis.net/road"] [itemprop="lanes"][content];
}
</style>

<feature>
  <properties>
      <table a="b" class="table-properties" itemscope itemtype="http://www.opengis.net/road">
        <tbody>
          <tr>
            <th scope="row">id</th>
            <td itemprop="id">10964418e33d457aabd6f6ab10dc2e4a</td>
          </tr>
          <tr>
            <th scope="row">theme</th>
            <td itemprop="theme" content="road">road</td>
          </tr>
          <tr>
            <th scope="row">theme</th>
            <td itemprop="name" content="route 66">Route 66</td>
          </tr>
          <tr>
            <th scope="row">theme</th>
            <td itemprop="lanes" content="3">3</td>
          </tr>
        </tbody>
      </table>
  </properties>
  <geometry>
     <polygon>
     </polygon>
  </geometry>
</feature>
----

== Other
(( Example: ))

(( Section 5 introduces the problem of vector tiling. It describes the situation prior to the testbed and discusses the requirements set by the sponsors. ))

(( Section 6 discusses the mathematical model behind the various tiling strategies. It provides recommendations on preferred strategies. ))

(( Section 7 presents the solution developed in this testbed. A clear mapping of requirements to solutions is provided. The section shows additional work is required to implement 3D tiles, which could not be addressed in this activity. ))

(( Section 8 provides a summary of the main findings and discusses links to other tasks such as WFS 3.0 and WMTS 2.3. ))

(( Annex A provides code snippets that illustrate the functionality of the Vector Tiling Engine and shall help to implement similar technology. It briefly discusses the key issues we experienced during implementation.))
